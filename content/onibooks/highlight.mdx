---
title: onipdf zoom
description: mupdf.js zoom 설정하기
date: 2024-09-22
---

<Callout>
  아시다시피 onipdf는 mupdf.js를 core를 두고 작업하고 있는 라이브러리다.
  simple-viewer를 보면 zoom을 %가 아닌, dpi를 기준으로 설정해주고 있는데 이런 개념을 모르는 사용자, 혹은 개념을 알고 있더라도 이 수치는 꽤나 익숙하지 않은 숫자라고 생각했다.
  나 역시도 불편하게 느껴지는 부분이기도하고.. 
  <br />
  그래서 zoom을 %로 입력 받는 형태로 바꿔주는 작업을 하며 기록해보기로 했다.
  <br />
  또한 지금은 96 DPI -> 100%로 화면 렌더링이 되고 있는데 가능하다면 현재 뷰포트를 기준으로 더 작은 사이즈를 기준으로 100%로 맞춰지게 렌더링 시켜주려 한다.
</Callout>

100이 기준일 때 현재 뷰포트를 기준으로 꽉 차게 렌더링이 되도록 한다.

render 옵션값이 설정되면 그때 줌 설정, 사이즈 설정

----------------------------------------------------------------

PDF는 특성상 뼈대를 미리 렌더링 시켜놔야한다.
처음에는 전체 페이지에 대한 뼈대를 그려놨는데, 생각해보니 3000 페이지 이상의 PDF라면, 3000개의 뼈대가 렌더링이 되어야 하는데 이처럼 너무 많은 DOM이 렌더링되어있으면 버벅거림, 일명 jank 현상이 발생할 수도 있다. 
그렇기 때문에 가장 최초에 렌더링 될 맥시멈 사이즈를 지정하기로 했다. 일단 데모에서는 10페이지로 설정했다.
그리고 한쪽 또는 두쪽 보기 모드 변경이 되거나, 페이지모드 또는 스크롤 모드가 변경 될 때마다 DOM 전체를 새로 그려주도록 하는 편이 나을 것 같다. (새로 그릴 때도 맥시멈 사이즈를 기준으로 한다.)

내가 설정한 정책은 아래와 같다.
1. 사용자가 페이지 index를 설정해서 전달한다.
2. PDF 라이브러리 쪽에서는 해당 index를 받아서 화면을 그려준다.
3. index가 0이라면 0 ~ 9 페이지 총 10개의 페이지를 렌더링한다. 
  1) 만약 0 또는 가장 마지막 페이지가 아니라면, 현재 index를 기준으로 앞 페이지 또는 뒤 페이지를 10개씩 렌더링한다.
  2) 예를 들어서 index가 3이라면 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 이렇게 렌더링 한다. (마이너스 페이지는 없고 총 페이지 수보다 큰 페이지를 렌더링하려는 것은 오류다.)

현재 index를 기준으로 항상 앞 뒤로 10 페이지씩 렌더링 되어 있도록한다.
예를 들어서 index가 40이라면 30 ~ 50 페이지는 렌더링이 되어있는 상태여야 한다.
이때 동적 페이지 로딩을 할 것이기 때문에, 만약 사용자가 0 페이지부터 읽기 시작해서 0 ~ 29 페이지도 지나쳐와서 이미 렌더링이 되어있는 상태라면,
0 ~ 29 페이지에 해당하는 DOM은 제거가 되어야 한다.
하지만 나중에 다시 0 ~ 29 페이지로 돌아갈 수 있는 상황도 고려해서 이미 렌더링 되었던 페이지는 캐싱해 두고 나중에 꺼내서 사용할 수 있도록 한다.

성능도 고려해야하기 때문에 아래와 같은 사항은 고려가 되었으면 좋겠다.
생성 및 제거는 requestIdleCallback으로 하여 메인 스레드에 대한 부담 (block 현상)을 줄이도록 한다. 또한. 생성 및 제거 작업이 많이 일어날 경우를 대비해 requestAnimationFrame으로 프레임마다 나누어 수행할 수 있도록 한다.


{/* 24.09.26
결국 다시 재정비하기로 했다.
1. 최소한의 DOM 업데이트하기: 현재 뷰포트에서 가까운 div만 생성한다.
2. 동적 페이지 로딩 앞 뒤로 div을 생성 및 제거하는 로직 시도
3. 생성 및 제거는 requestIdleCallback으로 하여 메인 스레드에 대한 부담 (block 현상)을 줄이도록 한다. 또한. 생성 및 제거 작업이 많이 일어날 경우를 대비해 requestAnimationFrame으로 프레임마다 나누어 수행할 수 있도록 한다.
4. 가상화 렌더링: 생성할 div 수는 제한하고(div를 추가할 때는 fragment를 사용한다.), 뷰포트에 가까운 div만 생성함으로 하여, 메모리와 렌더링 비율을 줄인다.

1. 우선 context.pageViews에는 미리 로드시킨 데이터를 담아두긴 해야한다.
2. 그 다음에는 생성할 div만큼 div를 생성해준다.
3. 기본 pdf 사이즈를 구하고, 현재 뷰포트 크기도 구해서 가로 또는 세로 사이즈에 맞게 렌더링 시키는 로직을 추가한다. 


줌은 sangte에서 관리한다.

그럼 이제 줌이 변경될 때 어떻게 변경해주어야 하는지 생각해봐야한다.
pageView.init()도 해줘야하고 컴포넌트도 다시 렌더링 해줘야한다..


useState를 사용하지 않으려고 했으나, pdf는 어쩔 수 없을거같다..? 왜냐면 어차피 사이즈를 업데이트 하려면 layout이 발생하기 때문에... */}


24.10.07
코드에 대한 설명...
1. 컴포넌트가 렌더링 될 때 가장 초기 설정은 아래와 같다.
  1) 현재 index를 기준으로 앞뒤로 최대 10개의 페이지만이 렌더링 된다. (총 렌더링 된 DOM은 최소 10개, 최대 20개)




코드 설명
ref: 현재 렌더링된 페이지 목록을 추적하기 위한 용도
state: 페이지 목록 UI를 보여주기 위한 용도
ref, context를 동기화 되도록 수정하기... 



24.10.15
다 필요없다.. 사파리랑 모바일에서 난리가 났다.
이전 스크롤의 위치를 기본적으로 기억해주는 크롬 브라우저랑은 달리,
사파리랑 모바일에서는 그런 처리를 자체적으로 해주고 있지 않기 때문에 inneradjustmentHTML을 해줄 때 미친듯이 observer에 의해서 반응이 일어나서 결국 메모리 초과에 이르게 된다.

결국, 뼈대는 다시 잡되, 캔버스 렌더링을 앞서 시도했던 앞뒤 최대 10페이지까지만 렌더링하는 로직을 추가하기로하고,
제거할 때는 캔버스 사이즈를 없애는 방식으로 하여 DOM 자체를 제거할 때 발생하는 reflow, repaint를 최소화하기로 했다. (mupdf demo에서도 이렇게 하고 있기도 하고..)
- 장점
  - reflow, repaint를 최소화
  - canvas 자체에 이벤트를 최초에 걸면 다시 걸지 않아도 되는 번거로움이 없다. (아직 이런 경우는 없었지만..)
  - 렌더링 비용 절감
- 단점
  - 페이지 수가 많아서(예를들어 코스모스 같은책의 경우) 캔버스 요소가 많아지면 메모리 측면에서는 좋지 않을 수 있어서 걱정이다..

-> 그래도 DOM 조작 최소화가 성능에 더 유리하기 때문에 해당 방식을 채택하기로 했다.
-> 나중에 많은 페이지를 가진 pdf 파일에서 너무 느려지는 이슈가 생기면 페이지 수에 따라서 DOM을 제거하는 알고리즘을 타는 방식을 적용하도록 하는 로직을 고려해봐도 좋을 것 같다.
